# xiaozhi-esp32-server

**xiaozhi-esp32-server** は、ESP32ベースのIoTデバイス向けに設計された包括的な音声AI相互作用システムです。このプロジェクトは、リアルタイム音声処理、自然言語理解、インテリジェント応答生成、および拡張可能な機能実行を統合し、開発者が高度な音声制御アプリケーションを構築するための完全なソリューションを提供します。

## 主要特徴

- **リアルタイム音声相互作用**: ESP32デバイスとサーバー間の低遅延WebSocket通信
- **モジュラーAIサービス**: ASR、LLM、TTS、VADプロバイダーの柔軟な選択と設定
- **拡張可能なプラグインシステム**: カスタム機能とHome Assistant統合のサポート
- **Webベース管理**: 設定、ユーザー管理、デバイス管理のための包括的な管理インターフェース
- **マルチ言語サポート**: 複数言語での音声認識と合成
- **柔軟なデプロイメント**: Dockerとソースコードからのデプロイメントオプション

---

## 1. システムアーキテクチャ概要

`xiaozhi-esp32-server`システムは、相互に連携する3つの主要コンポーネントで構成されています：

### 1.1. `xiaozhi-server` (コアAI処理エンジン)

**技術スタック**: Python 3.8+、WebSocket、非同期プログラミング

**主要責任**:
- ESP32デバイスとのリアルタイムWebSocket通信の管理
- 音声データストリームの受信と処理
- VAD（音声活動検出）、ASR（自動音声認識）、LLM（大規模言語モデル）、TTS（テキスト音声合成）サービスの統合
- プラグインベースの機能実行（天気照会、スマートホーム制御など）
- 対話コンテキストとメモリ管理

**コアモジュール**:
- `core/websocket_server.py`: WebSocketサーバーとクライアント接続管理
- `core/handle/`: 各種メッセージタイプ（音声、テキスト、制御）の処理ハンドラー
- `providers/`: 異なるAIサービスプロバイダー（OpenAI、Azure、ローカルモデルなど）の抽象化レイヤー
- `plugins_func/`: 拡張可能な機能プラグインシステム
- `config/`: 設定管理とリモート設定同期

### 1.2. `manager-api` (バックエンド管理サービス)

**技術スタック**: Java 17、Spring Boot 2.7、MyBatis-Plus、MySQL、Redis

**主要責任**:
- システム設定の永続化と管理
- ユーザー認証と認可（Apache Shiro使用）
- ESP32デバイスの登録と管理
- OTA（Over-The-Air）ファームウェア更新の管理
- `xiaozhi-server`への設定配信
- RESTful API提供

**コアモジュール**:
- `modules/config/`: システム設定管理
- `modules/user/`: ユーザー管理とロールベースアクセス制御
- `modules/device/`: ESP32デバイス登録と状態管理
- `modules/ota/`: ファームウェア更新管理
- `common/`: 共通ユーティリティとセキュリティ設定

### 1.3. `manager-web` (フロントエンド管理インターフェース)

**技術スタック**: Vue.js 2.6、Vue CLI、Vuex、Vue Router、Element UI

**主要責任**:
- 直感的なWeb管理インターフェースの提供
- システム設定の視覚的管理
- ユーザーとデバイス管理
- リアルタイム状態監視
- レスポンシブデザインとPWA機能

**コアモジュール**:
- `src/views/`: 各種管理ページコンポーネント
- `src/apis/`: `manager-api`とのHTTP通信封装
- `src/store/`: Vuex状態管理
- `src/router/`: ルーティング設定
- `src/components/`: 再利用可能なUIコンポーネント

---

## 2. `xiaozhi-server` 詳細分析

### 2.1. アーキテクチャ設計原則

`xiaozhi-server`は**モジュラー、プラガブル、拡張可能**な設計哲学に従っています：

1. **プロバイダーパターン**: 各AIサービス（ASR、LLM、TTS、VAD、意図認識、メモリ）は統一されたインターフェースを通じて抽象化され、異なる実装（OpenAI、Azure、ローカルモデルなど）間の簡単な切り替えを可能にします。

2. **非同期処理**: Python `asyncio`を大量使用し、高並行性と低遅延を実現し、複数のESP32デバイスの同時接続をサポートします。

3. **イベント駆動**: WebSocketメッセージの受信、音声データの処理、AI応答の生成はすべてイベント駆動方式で処理され、システムの応答性と拡張性を保証します。

4. **設定駆動**: ほぼすべてのシステム動作は設定ファイル（`config.yaml`）またはリモート設定（`manager-api`から取得）によって制御され、コード変更なしでの動作調整を可能にします。

### 2.2. コアワークフロー

**音声相互作用の完全なライフサイクル**:

1. **接続確立**: ESP32デバイスがWebSocket接続を開始
2. **音声キャプチャ**: デバイスがマイクロフォンデータをリアルタイムでストリーミング
3. **VAD処理**: 音声活動を検出し、有効な音声セグメントを識別
4. **ASR変換**: 音声をテキストに変換
5. **コンテキスト統合**: 対話履歴と利用可能な機能を結合
6. **LLM推論**: 自然言語理解と応答生成
7. **機能実行**: 必要に応じて外部機能を呼び出し
8. **TTS合成**: テキスト応答を音声に変換
9. **応答配信**: 音声データをESP32に送信して再生

### 2.3. プラグインシステム

`plugins_func/`ディレクトリは強力な拡張メカニズムを提供します：

- **関数定義**: 各プラグインはPython関数として実装され、明確な入力/出力スキーマを持ちます
- **自動発見**: システム起動時にすべての利用可能な関数を自動的にロードし、LLMに提供します
- **動的呼び出し**: LLMは提供されたスキーマに基づいて適切な関数を選択し呼び出します
- **結果統合**: 関数実行結果はLLMに返され、最終応答の生成に使用されます

**組み込みプラグインの例**:
- 天気照会
- 時間日付取得
- Home Assistant統合
- システム制御コマンド

---

## 3. `manager-web` & `manager-api` 詳細分析

### 3.1. `manager-api` アーキテクチャ

**レイヤー化アーキテクチャ**:

1. **Controller層**: RESTful APIエンドポイントの定義、要求検証、応答フォーマット
2. **Service層**: ビジネスロジックの実装、データ処理、外部サービス統合
3. **DAO層**: データアクセス抽象化、MyBatis-Plusを使用したデータベース操作
4. **Entity層**: データモデル定義、データベーステーブルとのマッピング

**セキュリティ機構**:
- **Apache Shiro**: 認証、認可、セッション管理
- **JWT Token**: ステートレス認証、フロントエンドとバックエンドの分離をサポート
- **ロールベースアクセス制御**: 細かい権限管理、異なるユーザーロールの異なる操作権限

**データ永続化**:
- **MySQL**: 主要データストレージ（ユーザー、デバイス、設定、ログなど）
- **Redis**: キャッシュ、セッション管理、一時データストレージ

### 3.2. `manager-web` アーキテクチャ

**Vue.jsエコシステム**:

1. **コンポーネント化開発**:
   - **ページレベルコンポーネント**: `src/views/`下の各管理ページ
   - **ビジネスコンポーネント**: 特定の機能領域に関連する複合コンポーネント
   - **基本コンポーネント**: `src/components/`下の再利用可能なUIコンポーネント

2. **状態管理 (Vuex)**:
   - **モジュール化ストア**: 異なる機能領域（ユーザー、設定、デバイスなど）を独立したVuexモジュールに分割
   - **状態の永続化**: 重要な状態（ユーザーログイン情報など）をlocalStorageに永続化
   - **リアクティブ更新**: 状態変更が自動的にUIコンポーネントの更新をトリガー

3. **ルーティング管理 (Vue Router)**:
   - **ネストされたルーティング**: 複雑な管理インターフェースの階層構造をサポート
   - **ルートガード**: 認証状態に基づくページアクセス制御
   - **遅延ロード**: 大きなアプリケーションの初期ロード時間を最適化

4. **API通信**:
   - **Axios封装**: `src/apis/`下で統一されたHTTP要求処理
   - **要求/応答インターセプター**: 自動的なトークン追加、エラー処理、ロード状態管理
   - **API模块化**: 異なる機能領域のAPIを独立したモジュールに分割

5. **UI/UXデザイン**:
   - **Element UI**: 成熟したVue.jsコンポーネントライブラリ、豊富なUIコンポーネントを提供
   - **レスポンシブレイアウト**: 異なる画面サイズでの良好な表示効果
   - **テーマカスタマイズ**: Element UIのテーマシステムを通じたブランドスタイルのカスタマイズ

6. **スタイルとリソース**:
   - **SCSS/SASS**: CSS前処理器、より強力なスタイル記述能力を提供
   - **スコープ付きスタイル**: Vue単一ファイルコンポーネント内部の`<style scoped>`タグは、現在のコンポーネントのみに作用するローカルスタイルの記述を可能にします。
   - `src/assets/`ディレクトリには画像、フォントなどの静的リソースが格納されます。

7. **ビルドとPWA特性**:
   - Vue CLIはWebpackを通じてすべてのコードとリソースを最適化された静的ファイルにパッケージ化し、本番デプロイメントに使用します。
   - `workbox-webpack-plugin`の使用（`service-worker.js`と`registerServiceWorker.js`ファイルに反映）は、プロジェクトがService Worker技術を統合していることを示しています。Service Workerはネットワークリクエストを傍受し、フロントエンドリソースのインテリジェントキャッシュ（後続のアクセス速度向上）を実現し、ネットワーク切断時にも一定のオフラインアクセス能力を提供する、PWAのコア技術の一つです。

8. **環境設定 (`.env`シリーズファイル)**:
   - プロジェクトルートディレクトリ下の`.env`（および`.env.development`、`.env.production`など）ファイルは環境変数の定義に使用されます。これらの変数（例：`manager-api`のベースURLを指定する`VUE_APP_API_BASE_URL`）は、アプリケーションコード内で`process.env.VUE_APP_XXX`の形式でアクセスでき、異なるビルド環境（開発、テスト、本番）に対して異なるパラメータを設定することを可能にします。

`manager-web`はこれらの技術の総合的な活用により、機能豊富で保守しやすく、ユーザーエクスペリエンスの良い管理インターフェースを構築し、`xiaozhi-esp32-server`システムの設定と監視に堅実なフロントエンドサポートを提供します。

---

## 4. データフローと相互作用メカニズム

`xiaozhi-esp32-server`システムは、各コンポーネント間で明確に定義されたデータフローと相互作用プロトコルを通じて協調動作します。主要な通信方式は、リアルタイム相互作用に最適化されたWebSocketプロトコルと、クライアント-サーバー要求に適用されるRESTful APIに依存しています。

**4.1.コア音声相互作用フロー (ESP32デバイス <-> `xiaozhi-server`)**

このフローはリアルタイムで、主にWebSocketを通じて低遅延、双方向のデータ交換を行います。

*   **通信プロトコル文書:**
    *   詳細な通信プロトコル説明文書は以下のアドレスでアクセスできます: https://ccnphfhqs21z.feishu.cn/wiki/M0XiwldO9iJwHikpXD5cEx71nKh
    *   この文書はESP32デバイスと`xiaozhi-server`間のWebSocket通信プロトコルを詳細に記述しており、以下を含みます:
        *   接続確立とハンドシェイクフロー
        *   音声データ転送フォーマット
        *   制御コマンドフォーマット
        *   状態レポートフォーマット
        *   エラー処理メカニズム

*   **接続確立とハンドシェイク:**
    *   ESP32デバイスはクライアントとして、`xiaozhi-server`の指定エンドポイント（例：`ws://<サーバーIP>:<WebSocketポート>/xiaozhi/v1/`）に対してWebSocket接続要求を能動的に開始します。
    *   `xiaozhi-server`（`core/websocket_server.py`）は接続を受信し、成功接続した各ESP32デバイスに対して独立した`ConnectionHandler`オブジェクトをインスタンス化して、そのセッションの全ライフサイクルを管理します。
    *   接続確立後、初期ハンドシェイクプロセス（`core/handle/helloHandle.py`で処理）が実行される可能性があり、デバイス識別、認証情報、プロトコルバージョン、または基本状態の交換に使用されます。

*   **音声アップリンク転送 (ESP32 -> `xiaozhi-server`)**:
    *   ユーザーがESP32デバイスに話しかけた後、デバイス上のマイクロフォンが生音声データ（通常はPCMまたはOpusなどの圧縮フォーマット）をキャプチャします。
    *   ESP32はこれらの音声データチャンク（chunks）をWebSocketの**バイナリメッセージ (binary messages)**として、`xiaozhi-server`の対応する`ConnectionHandler`にリアルタイムでプッシュします。
    *   サーバー側の`core/handle/receiveAudioHandle.py`モジュールが、これらの音声データの受信、バッファリング、処理を担当します。

*   **AIコア処理 (`xiaozhi-server`内部)**:
    *   **VAD (音声活動検出):** `receiveAudioHandle.py`は設定されたVADプロバイダー（SileroVADなど）を利用して音声ストリームを分析し、音声の開始と終了点を正確に識別し、無音やノイズセグメントを除去します。
    *   **ASR (自動音声認識):** 検出された有効な音声セグメントは、設定されたASRプロバイダー（ローカルのFunASRやクラウドサービス）に送信されます。ASRエンジンは音声信号をテキスト文字列に変換します。
    *   **NLU/LLM (自然言語理解/大規模言語モデル):** ASR出力のテキストは、Memoryプロバイダーから取得した現在の対話コンテキスト履歴、および`plugins_func/`からロードされた利用可能な関数（ツール）の記述スキーマと共に、設定されたLLMプロバイダーに渡されます。
    *   **関数呼び出し実行 (LLMが決定した場合):** LLMが分析後に外部関数の呼び出しが必要と判断した場合（例：天気照会、家電制御）、構造化された関数呼び出しリクエストを生成します。`core/handle/functionHandler.py`がこのリクエストを受信し、`plugins_func/`で定義された対応するPython関数を検索・実行し、関数の実行結果をLLMに返します。LLMはその後、この結果に基づいて最終的な自然言語応答を生成します。
    *   **応答生成:** LLMはすべての情報（ユーザー入力、コンテキスト、関数呼び出し結果など）を総合して最終的なテキスト応答を生成します。
    *   **記憶更新:** 現在のラウンドの相互作用（ユーザーの質問、LLMの応答、可能な機能呼び出し）はMemoryプロバイダーによって処理され、対話履歴を更新して後続の相互作用で使用されます。
    *   **TTS (テキスト音声合成):** LLMが生成した最終テキスト応答は設定されたTTSプロバイダーに送信され、テキストを音声データストリーム（MP3やWAVフォーマットなど）に合成します。

*   **音声ダウンリンク応答 (`xiaozhi-server` -> ESP32)**:
    *   TTSプロバイダーによって合成された音声データストリームは、`core/handle/sendAudioHandle.py`モジュールを通じて、WebSocketの**バイナリメッセージ**としてESP32デバイスにリアルタイムで送信されます。
    *   ESP32デバイスはこれらの音声データチャンクを受信し、スピーカーを通じてユーザーに即座に再生します。

*   **制御と状態メッセージ (双方向)**:
    *   音声ストリームに加えて、ESP32と`xiaozhi-server`間でもWebSocketを通じて**テキストメッセージ (text messages)**を交換します。これらのメッセージは通常JSON形式でカプセル化されます。
    *   **ESP32 -> Server:** デバイスは状態レポート（ネットワーク状況、マイクロフォン状態など）、エラーコード、または特定の制御コマンド（例：ユーザーのボタン押下によってトリガーされる「TTS再生停止」）を送信する可能性があります。
    *   **Server -> ESP32:** サーバーはデバイスに制御指令（「リスニング開始」、「リスニング停止」、感度調整、特定の設定パラメータの配信など）を送信する可能性があります。
    *   `core/handle/abortHandle.py`（中断要求の処理）、`core/handle/reportHandle.py`（デバイスレポートの処理）などのモジュールが、これらの制御/状態メッセージの解析と応答を担当します。

**4.2.管理と設定フロー (`manager-web` <-> `manager-api` <-> `xiaozhi-server`)**

このフローは主にHTTP/HTTPSベースのRESTful APIを使用したリクエスト-レスポンス型の相互作用に依存しています。

*   **管理者UIバックエンド相互作用 (`manager-web` -> `manager-api`)**:
    *   管理者が`manager-web`インターフェースで操作を実行する際（例：設定の保存、新規ユーザーの追加、ESP32デバイスの登録）：
        *   Vue.jsフロントエンドアプリケーション (`manager-web`) は、そのAPI封装モジュール（`src/apis/module/`に配置）を通じて、`manager-api`の対応するREST APIエンドポイントに非同期HTTP要求（通常はGET、POST、PUT、DELETE）を開始します。
        *   要求本文と応答本文は通常JSON形式を使用します。
        *   `manager-api`内の`@RestController`クラスがこれらの要求を受信します。**Apache Shiro**フレームワークが最初に要求の認証と認可チェックを実行します。
        *   検証を通過後、Controllerは要求を対応するServiceレイヤーに分散してビジネスロジックを処理します。ServiceレイヤーはMySQLデータベース（MyBatis-Plus経由）と相互作用し、Redisを利用してデータキャッシュを行う可能性があります。
        *   処理完了後、`manager-api`は`manager-web`にJSON形式のHTTP応答を返します。
        *   `manager-web`は応答結果に基づいてVuex状態ストレージとユーザーインターフェース表示を更新します。

*   **設定同期 (`manager-api` -> `xiaozhi-server`)**:
    *   `xiaozhi-server`の動作は`manager-api`から取得する動的設定（例：現在選択されているAIサービスプロバイダーとそのAPIキー）に依存しています。
    *   **プル機構 (Pull Mechanism):** `xiaozhi-server`内部の`config/manage_api_client.py`モジュールは、サーバー起動時または特定の更新トリガー（例：`WebSocketServer.update_config()`の呼び出し）を通じて、`manager-api`の指定エンドポイント（例：`modules/config/controller/`内のControllerによって提供）にHTTP GET要求を開始します。
    *   `manager-api`はその要求に応答し、`xiaozhi-server`に必要な設定データ（JSON形式）を返します。
    *   `xiaozhi-server`は設定を受信後、内部状態を更新し、新しい設定を有効にするために関連するAIサービスモジュールを再初期化する可能性があります。

*   **OTAファームウェア更新フロー (概念的記述)**:
    *   管理者は`manager-web`インターフェースを通じて新しいESP32ファームウェアパッケージを`manager-api`の特定エンドポイントにアップロードします。
    *   `manager-api`はファームウェアファイルを保存し、関連するメタデータ（バージョン番号、適用デバイスモデルなど）を記録します。
    *   管理者が特定デバイスのOTA更新をトリガーする際：
        *   `manager-api`は`xiaozhi-server`に通知する可能性があります（具体的な通知メカニズムはポーリングチェックポイント、または`xiaozhi-server`が更新通知を受信するAPIを公開、またはメッセージキューなどのより疎結合な方法の可能性があります）。
        *   `xiaozhi-server`はその後、WebSocketを通じて対象ESP32デバイスにファームウェアダウンロードURLを含む指令メッセージを送信できます。
        *   ESP32デバイスは指令を受信後、HTTP GET要求を通じてそのURLからファームウェアをダウンロードします。このURLは`xiaozhi-server`自身が実行する`SimpleHttpServer`が提供するパス（例：`/xiaozhi/ota/`）を指す可能性があり、または一部のアーキテクチャでは`manager-api`や専用ファイルサーバーを直接指す可能性もあります。

**4.3. 主要プロトコル概要**:

*   **WebSocket:** ESP32と`xiaozhi-server`間の通信リンクに選択されています。リアルタイム、低遅延、双方向のデータフロー転送（特に音声）、および非同期制御メッセージの配信に非常に適しているためです。
*   **RESTful APIs (HTTP/HTTPSベース、通常JSONをデータ交換形式として使用):** これはWebサービス間通信の標準方式です。`manager-web`（クライアント）と`manager-api`（サーバー）間のリクエスト-レスポンス相互作用、および`xiaozhi-server`（クライアントとして）が`manager-api`（サーバーとして）から設定情報を取得する際に使用されます。そのステートレス特性、広範なライブラリサポート、理解しやすいセマンティクスにより、このタイプの相互作用に理想的な選択となります。

この多プロトコル併用の通信戦略により、システム内の異なるタイプの相互作用ニーズが効率的かつ適切に処理され、リアルタイム性と標準化されたリクエスト-レスポンスモードの両方を考慮しています。

---

## 5. コア機能概要

`xiaozhi-esp32-server` システムは、開発者が先進的な音声制御アプリケーションを構築するための豊富な機能を提供します：

1.  **包括的な音声相互作用バックエンド:** 音声キャプチャガイダンスから応答生成とアクション実行までのエンドツーエンドソリューションを提供します。
2.  **モジュラーでプラガブルなAIサービス:**
    *   幅広いASR（自動音声認識）、LLM（大規模言語モデル）、TTS（テキスト音声合成）、VAD（音声活動検出）、意図認識、メモリプロバイダーをサポートします。
    *   これらのサービス（クラウドベースのAPIとローカルモデルを含む）の動的選択と設定を可能にし、コスト、パフォーマンス、プライバシー、言語要件のバランスを取ります。
3.  **高度な対話管理:**
    *   ウェイクワードによる対話開始、手動（プッシュツートーク）対話、システム応答のリアルタイム中断機能を備えた自然な相互作用をサポートします。
    *   マルチターン対話での一貫性を保つためのコンテキストメモリを含みます。
    *   一定期間の非活動後の自動スリープモードを備えています。
4.  **多言語対応:**
    *   選択されたASR/LLM/TTSプロバイダーに応じて、標準中国語、広東語、英語、日本語、韓国語など複数言語の認識と合成をサポートします。
5.  **プラグインによる拡張可能機能:**
    *   強力なプラグインシステムにより、開発者はカスタム「スキル」や関数（例：天気取得、スマートホームデバイス制御、ニュースアクセス）を追加できます。
    *   これらの関数は、提供されたスキーマに基づいてLLMの関数呼び出し機能によってトリガーできます。
    *   Home Assistant統合の組み込みサポートを含みます。
6.  **IoTデバイス制御:**
    *   音声コマンドによるスマートホームデバイスやその他のIoTハードウェアの管理と制御を目的とし、プラグインシステムを活用します。
7.  **Webベース管理コンソール (`manager-web` & `manager-api`)**:
    *   以下のための包括的なグラフィカルインターフェースを提供します：
        *   システム設定（AIサービス選択、APIキー、動作パラメータ）。
        *   ロールベースアクセス制御によるユーザー管理。
        *   ESP32デバイスの登録と管理。
        *   音声音色/TTS音声のカスタマイズ。
        *   ESP32デバイスのOTA（Over-The-Air）ファームウェア更新管理。
        *   システムパラメータと辞書の管理。
8.  **柔軟なデプロイメントオプション:**
    *   様々な環境とユーザーの専門知識に適応するため、Dockerコンテナ（簡素化されたサーバーのみまたはフルスタック設定用）とソースコードからの直接デプロイメントをサポートします。
9.  **動的リモート設定:**
    *   `xiaozhi-server`は`manager-api`から設定を取得でき、サーバーを再起動することなくAIプロバイダーと設定のリアルタイム更新を可能にします。
10. **オープンソースとコミュニティ駆動:**
    *   MITライセンスの下で提供され、透明性、協力、コミュニティ貢献を奨励します。
11. **コスト効率的なソリューション:**
    *   AIサービスの無料プランやローカルモデルを活用した「入門完全無料設定」パスを提供し、実験や個人プロジェクトを容易にします。
12. **プログレッシブWebアプリケーション (PWA) 特性:**
    *   `manager-web`コントロールパネルは、強化されたキャッシュと潜在的なオフラインアクセス機能のためのService Worker統合を含みます。
13. **詳細なAPIドキュメント:**
    *   `manager-api`は、RESTfulエンドポイントの明確な理解とテストのためにKnife4jを通じてOpenAPI (Swagger) ドキュメントを提供します。

これらの機能により、`xiaozhi-esp32-server`は複雑な音声相互作用アプリケーションを構築するための強力で適応性があり、ユーザーフレンドリーなプラットフォームとなります。

---

## 6. デプロイメントと設定概要

`xiaozhi-esp32-server`システムは柔軟性を重視して設計されており、異なる使用シナリオと要件に適応するための複数のデプロイメント方法と包括的な設定オプションを提供します。

**デプロイメントオプション:**

プロジェクトは主にDockerを使用したインストールプロセスの簡素化、またはより大きな制御と開発のためのソースコードからの直接デプロイメントを含む、複数の方法でデプロイできます。

1.  **Dockerベースのデプロイメント:**
    *   **簡素化インストール (`xiaozhi-server`のみ):** このオプションはコアのPythonベース`xiaozhi-server`のみをデプロイします。主に音声AI処理能力とIoT制御が必要で、完全なWeb管理インターフェースとデータベースサポート機能（OTAなど）を必要としないユーザーに適しています。このモードでは、設定は通常ローカルファイル（`config.yaml`）を通じて管理されますが、必要に応じて既存の`manager-api`インスタンスを指すことも可能です。
    *   **フルモジュールインストール (全コンポーネント):** この方案は全てのコアコンポーネントをデプロイします：`xiaozhi-server`、Javaベースの`manager-api`、Vue.jsベースの`manager-web`、および必要なデータベースサービス（MySQLとRedis）。これは包括的な設定と管理のためのWebコントロールパネルを含む、完全なシステム体験を提供します。
    *   プロジェクトは各サービスに`Dockerfile`定義を提供し、`docker-compose.yml`ファイル（例：基本版用の`docker-compose.yml`、フル機能版用の`docker-compose_all.yml`）を使用してマルチコンテナデプロイメントを編成・管理します。さらに、Docker環境の設定作業の一部を自動化するための`docker-setup.sh`スクリプトも提供される可能性があります。

2.  **ソースコードデプロイメント:**
    *   この方法では、各コンポーネントに対応する開発環境を手動で設定する必要があります：`xiaozhi-server`用のPython環境、`manager-api`用のJava/Maven環境、`manager-web`用のNode.js/Vue CLI環境。
    *   フルモジュールインストールの場合、MySQLとRedisデータベースサービスの手動インストールと設定も必要です。
    *   この方法は通常、プロジェクト開発、深いカスタマイズ、デバッグ、または環境に特別な要件がある本番シナリオで使用されます。

**設定管理:**

設定は、特にAIサービスプロバイダーの選択とAPIキーの管理において、システム動作をカスタマイズするための鍵となります。

1.  **`xiaozhi-server` 設定:**
    *   **ローカル`config.yaml`:** `xiaozhi-server`ルートディレクトリ下にあるYAML形式の主要設定ファイル。サーバーポート、選択されたAIサービスプロバイダー（ASR、LLM、TTS、VAD、意図認識、メモリモジュールなど）、それぞれのAPIキーまたはモデルパス、プラグイン設定、ログレベルなどを定義します。
    *   **`manager-api`を通じたリモート設定:** `xiaozhi-server`は`manager-api`から実行設定を取得するように設計されています。`manager-api`から取得した設定は通常、ローカル`config.yaml`の同名設定を上書きします。これにより2つの大きな利点があります：
        *   **集中管理:** 全ての設定を`manager-web`インターフェースを通じて統一管理できます。
        *   **動的更新:** `xiaozhi-server`は設定を更新し、完全な再起動なしにAIモジュールを再初期化できます。
    *   `xiaozhi-server`内の`config/config_loader.py`と`config/manage_api_client.py`が、設定の読み込み、マージ、`manager-api`からの取得ロジックを処理します。

2.  **`manager-api` 設定:**
    *   Spring Bootアプリケーションとして、その設定は主に`src/main/resources`ディレクトリ下の`application.properties`または`application.yml`ファイルを通じて管理されます。
    *   主要な設定項目には以下が含まれます：データベース接続情報（MySQLのURL、ユーザー名、パスワード）、Redisサーバーアドレスとポート、アプリケーションサービスポート（デフォルト8002）、Apache Shiroセキュリティ関連設定、統合された第三者サービス（阿里云SMSなど）の設定パラメータ。

3.  **`manager-web` 設定:**
    *   Vue.jsフロントエンドアプリケーションの環境固有設定は、プロジェクトルートディレクトリ下の`.env`シリーズファイル（例：`.env`、`.env.development`、`.env.production`）を通じて管理されます。
    *   ここで最も重要な設定は通常、`manager-api`バックエンドのAPIベースURLアドレス（例：`VUE_APP_API_BASE_URL`）で、フロントエンドアプリケーションはこのアドレスに全てのAPI要求を送信します。

4.  **事前定義された設定方案:**
    *   プロジェクトドキュメント（通常はREADME）では、以下のような一般的な設定組み合わせが推奨されます：
        *   **「入門完全無料設定」:** この方案は、クラウドAIサービスの無料プラン枠度または完全無料のローカルモデルを活用して、ユーザーの初期使用コストと運営費用を最大限に削減することを目的としています。
        *   **「全ストリーミング設定」:** この方案は、システムの応答速度と相互作用の流暢性を優先し、通常ストリーミング処理をサポートする（有料の可能性がある）AIサービスを選択します。
    *   これらの事前定義方案は、ユーザーが`xiaozhi-server`でAIサービスプロバイダーを設定する際（`manager-web`インターフェースまたは`config.yaml`の直接修正を通じて）のガイダンスを提供します。

フルモジュールデプロイメントの場合、`manager-web`コントロールパネルを大部分の設定タスクの主要操作インターフェースとして使用することが推奨されます。これは、`manager-api`によって永続化され、最終的に`xiaozhi-server`によって使用される各種設定を管理するためのユーザーフレンドリーな方法を提供するためです。

---
